<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>A-Frame â€¢ Start position + mouse move + background</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    body{margin:0}
    /* Prevent default browser gestures so mouse hold works cleanly */
    html, body, canvas { touch-action: none; }
  </style>
</head>
<body>
  <a-scene id="scene">
    <!-- Solid background color -->
    <a-sky color="#BBDFFF"></a-sky>

    <!-- Start/origin point: set your desired initial position here -->
    <a-entity id="start-point" position="4 1.6 0"></a-entity>

    <!-- Rig: look with mouse; walk by holding mouse buttons -->
    <a-entity id="rig" position="0 1.6 0" mouse-walk="speed: 1.6; backSpeed: 1.2">
      <a-entity camera look-controls></a-entity>
    </a-entity>
  </a-scene>

  <script>
    // Move rig to start-point when the scene loads
    document.getElementById('scene').addEventListener('loaded', () => {
      const rig   = document.getElementById('rig');
      const start = document.getElementById('start-point').object3D.position;
      rig.object3D.position.copy(start);
    });

    // Minimal mouse-walk: hold LEFT = forward, RIGHT = backward
    AFRAME.registerComponent('mouse-walk', {
      schema: { speed: {default: 1.6}, backSpeed: {default: 1.2} },
      init: function () {
        this.sign = 0;                       // 0 still, +1 forward, -1 backward
        this.dir  = new THREE.Vector3();

        this._ctx = e => e.preventDefault(); // allow right-click hold without menu
        window.addEventListener('contextmenu', this._ctx);

        this._md = e => { this.sign = (e.button === 2) ? -1 : +1; };
        this._mu = () => { this.sign = 0; };
        window.addEventListener('mousedown', this._md);
        window.addEventListener('mouseup',   this._mu);
        window.addEventListener('blur',      this._mu);
      },
      tick: function (t, dt) {
        if (this.sign === 0) return;
        const cam = this.el.sceneEl.camera;
        if (!cam) return;

        // Forward from camera (flatten Y)
        this.dir.set(0, 0, -1).applyQuaternion(cam.quaternion);
        this.dir.y = 0; this.dir.normalize();

        const spd  = this.sign > 0 ? this.data.speed : this.data.backSpeed;
        const dist = spd * (dt / 1000) * this.sign;
        this.el.object3D.position.addScaledVector(this.dir, dist);
      },
      remove: function () {
        window.removeEventListener('contextmenu', this._ctx);
        window.removeEventListener('mousedown',   this._md);
        window.removeEventListener('mouseup',     this._mu);
        window.removeEventListener('blur',        this._mu);
      }
    });
  </script>
</body>
</html>
